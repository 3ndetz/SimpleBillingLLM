# infra/db/user_repository_impl.py
import sqlite3
import os
from typing import Optional, List
from datetime import datetime

# --- Start of fix ---
# Adjust import paths for direct script execution vs. module import
try:
    # This works when imported as a module
    from core.entities.user import User
    from core.repositories.user_repository import UserRepository
except ImportError:
    # This works when run as a script
    import sys
    # Go up two levels to the project root (from infra/db -> infra -> root)
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    if project_root not in sys.path:
        sys.path.insert(0, project_root)
    from core.entities.user import User
    from core.repositories.user_repository import UserRepository
# --- End of fix ---

# Define DB Path (relative to this file's location)
# Go up three levels from infra/db to the project root, then into 'data'
DB_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), 'data')
DB_PATH = os.path.join(DB_DIR, 'billing_llm.db')

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    # Ensure the directory exists, although initialize_db should have created it
    os.makedirs(DB_DIR, exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row # Return rows as dictionary-like objects
    return conn

class SQLiteUserRepository(UserRepository):
    """SQLite implementation of the UserRepository interface."""

    def _map_row_to_user(self, row: sqlite3.Row) -> Optional[User]:
        """Helper method to map a database row to a User entity."""
        if row:
            return User(
                id=row['id'],
                name=row['name'],
                telegram_id=row['telegram_id'],
                balance=row['balance'],
                # Ensure created_at is parsed correctly if stored as TEXT or handled if TIMESTAMP
                created_at=datetime.fromisoformat(row['created_at']) if isinstance(row['created_at'], str) else row['created_at']
            )
        return None

    def add(self, user: User) -> User:
        """Adds a new user to the database."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute(
                "INSERT INTO users (name, telegram_id, balance) VALUES (?, ?, ?)",
                (user.name, user.telegram_id, user.balance)
            )
            user.id = cursor.lastrowid # Get the ID assigned by the database
            # Fetch the created_at timestamp generated by the database
            cursor.execute("SELECT created_at FROM users WHERE id = ?", (user.id,))
            row = cursor.fetchone()
            if row:
                 user.created_at = datetime.fromisoformat(row['created_at']) if isinstance(row['created_at'], str) else row['created_at']
            conn.commit()
            print(f"User added successfully with ID: {user.id}")
        except sqlite3.IntegrityError as e:
            print(f"Error adding user (likely duplicate telegram_id): {e}")
            # Optionally re-raise or handle differently
            raise
        except Exception as e:
            print(f"An unexpected error occurred while adding user: {e}")
            conn.rollback() # Rollback in case of other errors
            raise
        finally:
            conn.close()
        return user

    def get_by_id(self, user_id: int) -> Optional[User]:
        """Retrieves a user by their database ID."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute("SELECT id, name, telegram_id, balance, created_at FROM users WHERE id = ?", (user_id,))
            row = cursor.fetchone()
            return self._map_row_to_user(row)
        except Exception as e:
            print(f"An error occurred fetching user by ID {user_id}: {e}")
            return None
        finally:
            conn.close()

    def get_by_telegram_id(self, telegram_id: str) -> Optional[User]:
        """Retrieves a user by their Telegram ID."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute("SELECT id, name, telegram_id, balance, created_at FROM users WHERE telegram_id = ?", (telegram_id,))
            row = cursor.fetchone()
            return self._map_row_to_user(row)
        except Exception as e:
            print(f"An error occurred fetching user by Telegram ID {telegram_id}: {e}")
            return None
        finally:
            conn.close()

    def update_balance(self, user_id: int, new_balance: float) -> bool:
        """Updates the balance for a specific user."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute("UPDATE users SET balance = ? WHERE id = ?", (new_balance, user_id))
            conn.commit()
            # Check if any row was actually updated
            success = cursor.rowcount > 0
            if success:
                print(f"Successfully updated balance for user ID: {user_id}")
            else:
                print(f"User ID: {user_id} not found for balance update.")
            return success
        except Exception as e:
            print(f"An error occurred updating balance for user ID {user_id}: {e}")
            conn.rollback()
            return False
        finally:
            conn.close()

    def list_all(self) -> List[User]:
        """Retrieves a list of all users."""
        conn = get_db_connection()
        cursor = conn.cursor()
        users = []
        try:
            cursor.execute("SELECT id, name, telegram_id, balance, created_at FROM users ORDER BY created_at DESC")
            rows = cursor.fetchall()
            for row in rows:
                user = self._map_row_to_user(row)
                if user:
                    users.append(user)
            return users
        except Exception as e:
            print(f"An error occurred listing all users: {e}")
            return [] # Return empty list on error
        finally:
            conn.close()

# Example Usage (Optional - for testing this script directly)
if __name__ == '__main__':
    # --- Start of fix ---
    # Ensure correct imports when run as script (already handled above)
    # Add project root to sys.path if not already done
    project_root_for_test = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    if project_root_for_test not in sys.path:
        sys.path.insert(0, project_root_for_test)
    # --- End of fix ---

    print("Testing SQLiteUserRepository...")
    # Ensure DB is initialized before running tests
    try:
        # --- Start of fix ---
        # Import initialize_database relative to the adjusted path
        from infra.db.initialize_db import initialize_database
        # --- End of fix ---
        print("Initializing database for test (this will reset data)...")
        # Uncomment the next line ONLY if you want to wipe and recreate the DB for each test run
        # initialize_database()
        print("Database should be ready (or run initialize_db.py manually if commented out).")
    except ImportError as e:
        print(f"Could not import initialize_db: {e}. Make sure it's runnable and DB exists.")
        # Decide if you want to exit or continue assuming DB exists
        # exit(1) # Exit if DB initialization is critical for the test


    repo = SQLiteUserRepository()

    # Test adding a user
    print("\nTesting add...")
    test_telegram_id = f'test_user_{int(datetime.now().timestamp())}' # More unique
    try:
        # Use a unique telegram_id for testing each time or handle duplicates
        new_user = User(name='Lumi Test', telegram_id=test_telegram_id, balance=50.0)
        added_user = repo.add(new_user)
        print(f"Added user: {added_user}")
        test_user_id = added_user.id
        if not test_user_id:
             raise ValueError("Added user did not receive an ID.") # Should not happen if add is successful
    except Exception as e:
        print(f"Could not add test user {test_telegram_id}: {e}")
        # Attempt to fetch if add failed, assuming it might be due to duplicate
        # Use the telegram_id we just tried to add
        print(f"Attempting to fetch user with telegram_id: {test_telegram_id}")
        existing_user = repo.get_by_telegram_id(test_telegram_id)
        if existing_user:
            print(f"Found existing user: {existing_user}")
            test_user_id = existing_user.id # Use the existing user's ID for further tests
        else:
            print(f"Could not find user {test_telegram_id}. Aborting further tests for this user.")
            test_user_id = None # Ensure it's None if user couldn't be added/found

    if test_user_id:
        # Test get_by_id
        print("\nTesting get_by_id...")
        fetched_user = repo.get_by_id(test_user_id)
        print(f"Fetched user by ID: {fetched_user}")

        # Test get_by_telegram_id
        print("\nTesting get_by_telegram_id...")
        fetched_user_tg = repo.get_by_telegram_id('987654321')
        print(f"Fetched user by Telegram ID: {fetched_user_tg}")

        # Test update_balance
        print("\nTesting update_balance...")
        success = repo.update_balance(test_user_id, 75.5)
        print(f"Balance update successful: {success}")
        updated_user = repo.get_by_id(test_user_id)
        print(f"User after balance update: {updated_user}")

    # Test list_all
    print("\nTesting list_all...")
    all_users = repo.list_all()
    print(f"Total users found: {len(all_users)}")
    for u in all_users:
        print(u)

    print("\nTesting completed.")
