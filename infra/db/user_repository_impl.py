# infra/db/user_repository_impl.py
import sqlite3
import os
from typing import Optional, List # Keep List for list_all
from datetime import datetime

# --- Start of fix ---
# Adjust import paths for direct script execution vs. module import
try:
    # This works when imported as a module
    from core.entities.user import User
    from core.repositories.user_repository import UserRepository
except ImportError:
    # This works when run as a script
    import sys
    # Go up two levels to the project root (from infra/db -> infra -> root)
    project_root = os.path.dirname(
        os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    )
    if project_root not in sys.path:
        sys.path.insert(0, project_root)
    from core.entities.user import User
    from core.repositories.user_repository import UserRepository
# --- End of fix ---

# Define DB Path (relative to this file's location)
# Go up three levels from infra/db to the project root, then into 'data'
DB_DIR = os.path.join(
    os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))),
    'data'
)
DB_PATH = os.path.join(DB_DIR, 'billing_llm.db')

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    # Ensure the directory exists, although initialize_db should have created it
    os.makedirs(DB_DIR, exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row  # Return rows as dictionary-like objects
    return conn

class SQLiteUserRepository(UserRepository):
    """SQLite implementation of the UserRepository interface."""

    def _map_row_to_user(self, row: sqlite3.Row) -> Optional[User]:
        """Helper method to map a database row to a User entity."""
        if row:
            return User(
                id=row['id'],
                name=row['name'],
                telegram_id=row['telegram_id'],
                balance=row['balance'],
                password_hash=row['password_hash'],
                api_key=row['api_key'],
                created_at=datetime.fromisoformat(row['created_at'])
                if isinstance(row['created_at'], str) else row['created_at']
            )
        return None

    def add(self, user: User) -> User:
        """Adds a new user to the database."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute(
                """INSERT INTO users
                   (name, telegram_id, balance, password_hash, api_key)
                   VALUES (?, ?, ?, ?, ?)""",
                (user.name, user.telegram_id, user.balance,
                 user.password_hash, user.api_key)
            )
            user.id = cursor.lastrowid  # Get the ID assigned by the database
            # Fetch the created_at timestamp generated by the database
            cursor.execute(
                "SELECT created_at FROM users WHERE id = ?", (user.id,)
            )
            row = cursor.fetchone()
            if row and row['created_at']: # Ensure created_at is not None
                user.created_at = datetime.fromisoformat(row['created_at']) \
                    if isinstance(row['created_at'], str) else row['created_at']
            conn.commit()
            print(f"User added successfully with ID: {user.id}")
        except sqlite3.IntegrityError as e:
            if "UNIQUE constraint failed: users.name" in str(e):
                print(f"Error adding user: Name '{user.name}' already exists.")
            elif "UNIQUE constraint failed: users.telegram_id" in str(e):
                print(
                    f"Error adding user: Telegram ID '{user.telegram_id}' already exists."
                )
            else:
                print(f"Error adding user (IntegrityError): {e}")
            raise
        except Exception as e:
            print(f"An unexpected error occurred while adding user: {e}")
            conn.rollback()  # Rollback in case of other errors
            raise
        finally:
            conn.close()
        return user

    def get_by_id(self, user_id: int) -> Optional[User]:
        """Retrieves a user by their database ID."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute(
                """SELECT id, name, telegram_id, balance, password_hash,
                          api_key, created_at
                   FROM users WHERE id = ?""",
                (user_id,)
            )
            row = cursor.fetchone()
            return self._map_row_to_user(row)
        except Exception as e:
            print(f"An error occurred fetching user by ID {user_id}: {e}")
            return None
        finally:
            conn.close()

    def get_by_telegram_id(self, telegram_id: str) -> Optional[User]:
        """Retrieves a user by their Telegram ID."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute(
                """SELECT id, name, telegram_id, balance, password_hash,
                          api_key, created_at
                   FROM users WHERE telegram_id = ?""",
                (telegram_id,)
            )
            row = cursor.fetchone()
            return self._map_row_to_user(row)
        except Exception as e:
            print(
                f"An error occurred fetching user by Telegram ID {telegram_id}: {e}"
            )
            return None
        finally:
            conn.close()

    def get_by_name(self, name: str) -> Optional[User]:
        """Retrieves a user by their name."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute(
                """SELECT id, name, telegram_id, balance, password_hash,
                          api_key, created_at
                   FROM users WHERE name = ?""",
                (name,)
            )
            row = cursor.fetchone()
            return self._map_row_to_user(row)
        except Exception as e:
            print(f"An error occurred fetching user by name '{name}': {e}")
            return None
        finally:
            conn.close()

    def update_balance(self, user_id: int, new_balance: float) -> bool:
        """Updates the balance for a specific user."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute(
                "UPDATE users SET balance = ? WHERE id = ?",
                (new_balance, user_id)
            )
            conn.commit()
            success = cursor.rowcount > 0
            if success:
                print(f"Successfully updated balance for user ID: {user_id}")
            else:
                print(f"User ID: {user_id} not found for balance update.")
            return success
        except Exception as e:
            print(
                f"An error occurred updating balance for user ID {user_id}: {e}"
            )
            conn.rollback()
            return False
        finally:
            conn.close()

    def list_all(self) -> List[User]:
        """Retrieves a list of all users."""
        conn = get_db_connection()
        cursor = conn.cursor()
        users = []
        try:
            cursor.execute(
                """SELECT id, name, telegram_id, balance, password_hash,
                          api_key, created_at
                   FROM users ORDER BY created_at DESC"""
            )
            rows = cursor.fetchall()
            for row in rows:
                user = self._map_row_to_user(row)
                if user:
                    users.append(user)
            return users
        except Exception as e:
            print(f"An error occurred listing all users: {e}")
            return []  # Return empty list on error
        finally:
            conn.close()

    def update_password_hash(self, user_id: int, password_hash: str) -> bool:
        """Updates the password_hash for a specific user."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute(
                "UPDATE users SET password_hash = ? WHERE id = ?",
                (password_hash, user_id)
            )
            conn.commit()
            return cursor.rowcount > 0
        finally:
            conn.close()

    def update_api_key(self, user_id: int, api_key: str) -> bool:
        """Updates the api_key for a specific user."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute(
                "UPDATE users SET api_key = ? WHERE id = ?",
                (api_key, user_id)
            )
            conn.commit()
            return cursor.rowcount > 0
        finally:
            conn.close()

    def get_by_api_key(self, api_key: str) -> Optional[User]:
        """Retrieves a user by their API key."""
        conn = get_db_connection()
        cursor = conn.cursor()
        try:
            cursor.execute(
                """SELECT id, name, telegram_id, balance, password_hash,
                          api_key, created_at
                   FROM users WHERE api_key = ?""",
                (api_key,)
            )
            row = cursor.fetchone()
            return self._map_row_to_user(row)
        finally:
            conn.close()


# Example Usage (Optional - for testing this script directly)
if __name__ == '__main__':
    # Ensure correct imports when run as script (already handled above)
    # Add project root to sys.path if not already done
    project_root_for_test = os.path.dirname(
        os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    )
    if project_root_for_test not in sys.path:
        sys.path.insert(0, project_root_for_test)

    print(
        "Running SQLiteUserRepository tests... "
        "Ensure DB is initialized separately."
    )

    repo = SQLiteUserRepository()

    # Test 1: Add a new user
    timestamp_ms = int(datetime.now().timestamp() * 1000)
    test_name = f'Test User {timestamp_ms}'
    test_telegram_id = f'test_tg_{timestamp_ms}'
    test_password_hash = "dummy_hash_main_test"
    test_api_key = f"dummy_api_key_main_test_{timestamp_ms}"

    new_user = User(
        name=test_name,
        telegram_id=test_telegram_id,
        balance=100.0,
        password_hash=test_password_hash,
        api_key=test_api_key
    )
    added_user = None
    test_user_id = None
    try:
        print(f"Attempting to add user: {new_user.name}")
        added_user = repo.add(new_user)
        assert added_user.id is not None, "Added user should have an ID."
        assert added_user.name == test_name
        assert added_user.created_at is not None, "created_at should be set."
        print(f"User added: {added_user.name}, ID: {added_user.id}, Created: {added_user.created_at}")
        test_user_id = added_user.id
    except Exception as e:
        print(f"Error during add user test: {e}")
        # test_user_id remains None

    if test_user_id:
        # Test 2: Get user by ID
        print(f"Attempting to get user by ID: {test_user_id}")
        retrieved_user = repo.get_by_id(test_user_id)
        assert retrieved_user is not None, "User should be found by ID."
        assert retrieved_user.id == test_user_id
        assert retrieved_user.name == test_name
        assert retrieved_user.password_hash == test_password_hash
        assert retrieved_user.api_key == test_api_key
        print(f"User retrieved by ID: {retrieved_user.name}")

        # Test 3: Get user by Telegram ID
        print(f"Attempting to get user by Telegram ID: {test_telegram_id}")
        retrieved_user_tg = repo.get_by_telegram_id(test_telegram_id)
        assert retrieved_user_tg is not None, "User should be found by Telegram ID."
        assert retrieved_user_tg.telegram_id == test_telegram_id
        assert retrieved_user_tg.name == test_name
        print(f"User retrieved by Telegram ID: {retrieved_user_tg.name}")

        # Test 4: Get user by Name
        print(f"Attempting to get user by Name: {test_name}")
        retrieved_user_name = repo.get_by_name(test_name)
        assert retrieved_user_name is not None, "User should be found by Name."
        assert retrieved_user_name.name == test_name
        print(f"User retrieved by Name: {retrieved_user_name.name}")

        # Test 5: Update balance
        print(f"Attempting to update balance for user ID: {test_user_id}")
        new_balance = 150.75
        update_success = repo.update_balance(test_user_id, new_balance)
        assert update_success, "Balance update should be successful."
        updated_user = repo.get_by_id(test_user_id)
        assert updated_user is not None
        assert updated_user.balance == new_balance, "Balance should be updated."
        print(f"Balance updated for {updated_user.name} to {updated_user.balance}")

        # Test 6: Update password hash
        new_password_hash = "new_dummy_hash_updated"
        print(f"Attempting to update password hash for user ID: {test_user_id}")
        update_ph_success = repo.update_password_hash(test_user_id, new_password_hash)
        assert update_ph_success, "Password hash update should be successful."
        updated_user_ph = repo.get_by_id(test_user_id)
        assert updated_user_ph is not None
        assert updated_user_ph.password_hash == new_password_hash, "Password hash should be updated."
        print(f"Password hash updated for {updated_user_ph.name}")

        # Test 7: Update API key
        new_api_key = f"new_dummy_api_key_updated_{timestamp_ms}"
        print(f"Attempting to update API key for user ID: {test_user_id}")
        update_ak_success = repo.update_api_key(test_user_id, new_api_key)
        assert update_ak_success, "API key update should be successful."
        updated_user_ak = repo.get_by_id(test_user_id)
        assert updated_user_ak is not None
        assert updated_user_ak.api_key == new_api_key, "API key should be updated."
        print(f"API key updated for {updated_user_ak.name}")

        # Test 8: Get by API key
        print(f"Attempting to get user by new API key: {new_api_key}")
        retrieved_by_api_key = repo.get_by_api_key(new_api_key)
        assert retrieved_by_api_key is not None, "User should be found by API key."
        assert retrieved_by_api_key.id == test_user_id
        print(f"User retrieved by API key: {retrieved_by_api_key.name}")
    else:
        print("Skipping further tests as initial user add failed or was skipped.")


    # Test 9: List all users
    print("Attempting to list all users...")
    all_users = repo.list_all()
    assert isinstance(all_users, list), "Should return a list."
    if added_user and test_user_id: # Check if a user was successfully added
        assert any(u.id == test_user_id for u in all_users), "Newly added user should be in the list."
    print(f"Listed {len(all_users)} users. First few: {[(u.name, u.id) for u in all_users[:3]]}")

    # Test 10: Attempt to add user with duplicate name (if a user was added)
    if added_user and test_user_id:
        print(f"Attempting to add user with duplicate name: {test_name}")
        duplicate_user_name = User(
            name=test_name, # Same name
            telegram_id=f"another_tg_{timestamp_ms}_dup", # Different telegram_id
            balance=50.0,
            password_hash="hash123_dup_name",
            api_key=f"key_{timestamp_ms}_dup_name"
        )
        try:
            repo.add(duplicate_user_name)
            assert False, "Should have raised IntegrityError for duplicate name."
        except sqlite3.IntegrityError as e:
            assert "UNIQUE constraint failed: users.name" in str(e), "Error message should indicate duplicate name."
            print(f"Correctly caught error for duplicate name: {e}")
        except Exception as e:
            assert False, f"Wrong exception type for duplicate name: {e}"

    # Test 11: Attempt to add user with duplicate telegram_id (if a user was added)
    if added_user and test_user_id:
        print(f"Attempting to add user with duplicate telegram_id: {test_telegram_id}")
        duplicate_user_tg = User(
            name=f"Another Name {timestamp_ms}_dup", # Different name
            telegram_id=test_telegram_id, # Same telegram_id
            balance=70.0,
            password_hash="hash456_dup_tg",
            api_key=f"key_{timestamp_ms}_dup_tg"
        )
        try:
            repo.add(duplicate_user_tg)
            assert False, "Should have raised IntegrityError for duplicate telegram_id."
        except sqlite3.IntegrityError as e:
            assert "UNIQUE constraint failed: users.telegram_id" in str(e), "Error message should indicate duplicate telegram_id."
            print(f"Correctly caught error for duplicate telegram_id: {e}")
        except Exception as e:
            assert False, f"Wrong exception type for duplicate telegram_id: {e}"


    print("SQLiteUserRepository tests completed.")
